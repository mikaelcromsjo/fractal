Here’s a structured overview of your **Fractal Governance backend project**, mapping files to their main classes/functions, including inputs, outputs, and models used. I’ve organized it by folder so you can quickly see the logic flow and data structures.

---

## **1. `app/domain`**

Pure domain logic (no DB, no FastAPI). All functions operate on plain Python types.

### `fractal_service.py`

* **partition_into_groups(member_ids: List[int], group_size: int) → List[List[int]]**
  Input: list of user IDs, target group size
  Output: list of lists of user IDs
  Comments: Splits members into groups; last group may be smaller.

* **balance_groups(groups: List[List[int]], target_size: int) → List[List[int]]**
  Input: list of groups, target size
  Output: balanced groups
  Comments: Re-chunks members to make groups more equal in size.

* **random_grouping(members: List[Dict], options: Dict) → List[List[int]]**
  Input: list of member dicts (`{"user_id": int, ...}`), options (`group_size`, `seed`)
  Output: grouped user IDs
  Comments: Shuffles members randomly; placeholder for future grouping logic.

* **select_representative_from_group(messages: List[Dict], members: List[int]) → Optional[int]**
  Input: list of message dicts with votes, member IDs
  Output: selected representative ID
  Comments: Chooses user with highest average votes.

* **compute_top_proposals(proposals: List[Dict], top_n: int) → List[Dict]**
  Input: proposals with vote dicts, number of top proposals
  Output: list of top proposals
  Comments: Sorted by average vote.

* **propagate_proposals(top_proposals: List[Dict]) → List[Dict]**
  Input: top proposals
  Output: new proposals for next round, type='propagated'

* **merge_proposals(proposals_to_merge: List[Dict], new_title: str, new_body: str) → Dict**
  Input: proposals to merge, new title/body
  Output: merged proposal with `merged_from` field

* **select_representatives_for_all_groups(groups: List[Dict], top_proposals_per_group: Dict[int, List[Dict]]) → Dict[int,int]**
  Input: list of groups, mapping group_id → top proposals
  Output: mapping group_id → representative_id

---

## **2. `app/infrastructure`**

Handles DB access, session management, and storage.

### `db/session.py`

* **engine**: SQLAlchemy engine
* **SessionLocal**: sessionmaker
* **Base**: declarative base for models

### `models/*.py`

**SQLAlchemy models** (all inherit `Base`):

* `Fractal`: id, name, description, start_date, status
* `User`: id, username, email
* `FractalMember`: id, user_id, fractal_id
* `Round`: id, fractal_id, round_number, start_date, end_date
* `Group`: id, round_id, name
* `GroupMember`: id, group_id, user_id
* `Proposal`: id, group_id, user_id, title, description, type, merged_from
* `ProposalMerge`: id, new_proposal_id, old_proposal_ids
* `Comment`: id, proposal_id, parent_comment_id, user_id, content
* `ProposalVote`: id, proposal_id, user_id, vote
* `CommentVote`: id, comment_id, user_id, vote
* `RepresentativeSelection`: id, group_id, user_id, round_id
* `AuditLog`: id, action, actor_id, target_id, timestamp

---

## **3. `app/services`**

Service layer connecting DB/models to domain logic.

**Typical functions:**

* `create_fractal(db, name, desc, start_date) → Fractal`
* `join_fractal(db, fractal_id, user_id) → FractalMember`
* `create_groups(db, round_id, members, group_size, preferences) → List[Group]`
* `create_proposal(db, group_id, user_id, title, body) → Proposal`
* `create_comment(db, proposal_id, parent_comment_id, user_id, content) → Comment`
* `cast_vote(db, user_id, target_id, vote, type) → ProposalVote/CommentVote`
* `select_representatives(db, group_id) → RepresentativeSelection`
* `promote_representatives(db, next_round_id, reps: List[User]) → Groups`

All service functions call **domain functions** to calculate groups, top proposals, or representative selection.

---

## **4. `app/api/routers`**

FastAPI routers mapping HTTP endpoints to service functions.

* `fractals.py`:

  * POST `/fractals/` → create fractal
  * POST `/fractals/join` → join fractal
  * GET `/fractals/` → list fractal
  * POST `/start` -> Force start fractal (admin and testing)

* `users.py`:

  * GET `/users/{user_id}` → get user info
  * POST `/users/create` → create user

* `groups.py`:

  * POST `/groups/create` → generate level groups
  * GET `/groups/{group_id}` → list members

* `proposals.py`:

  * POST `/proposals/create` → create proposal
  * GET `/proposals/{proposal_id}` → get proposal info

* `comments.py`:

  * POST `/comments/create` → comment on proposal/comment

* `votes.py`:

  * POST `/votes/proposal` → cast proposal vote
  * POST `/votes/comment` → cast comment vote

* `admin.py`:

  * GET `/admin/status` → overview
  * POST `/admin/promote` → promote top proposals

---

## **5. `app/config`**

* `settings.py`

  * Environment variables, DB URL, default group size, proposal limits, deliberation times

---

## **6. `scripts`**

* `init_db.py`: Creates all tables using `Base.metadata.create_all(engine)`
* `generate_test_data.py`: Populates DB with sample users, fractals, proposals
* `inspect_db.py`: Debug helper for checking DB contents

---

## **Data Flow Overview**

1. **User triggers UI command → API router → service function**
2. **Service function queries DB → extracts data → calls domain logic**
3. **Domain logic functions** (pure Python) compute groups, top proposals, reps, merges
4. **Service layer stores results → DB**
5. **Bot / UI fetches updated data from DB → sends messages**

---

This overview maps every important file and function, input/output types, and models involved, giving a complete blueprint of the backend architecture.


