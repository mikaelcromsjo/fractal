Perfect! Here’s a clear **function map diagram** for your Fractal Governance project, showing **bot commands → service account functions → backend endpoints**, including **inputs and outputs**. I’ll write it as a structured table/flow so it’s easy to understand and use for development.

---

## **Fractal Governance: Bot → Service → Backend Map**

| **Bot Command / Trigger** | **Service / Adapter Function**              | **Backend Endpoint**                | **Inputs**                                         | **Outputs / User Feedback**                |
| ------------------------- | ------------------------------------------- | ----------------------------------- | -------------------------------------------------- | ------------------------------------------ |
| `/start_fractal`          | `validate_user()` (bot helper)              | `POST /fractals/create`             | `name: str`, `description: str`, `start_date: str` | Success/failure message: “Fractal created” |
| `/join`                   | `validate_user()`                           | `POST /fractals/join`               | `name: str`                                        | Confirmation: “You joined Fractal X”       |
| `/proposal`               | `validate_user()`                           | `POST /proposals/create`            | `name: str`, `description: str`                    | Confirmation: “Proposal submitted”         |
| `/proposal_vote`          | `validate_user()`, `inline_vote_keyboard()` | `POST /proposals/vote`              | `proposal_id: int`, `vote: int (1-10)`             | Confirmation: “Vote recorded”              |
| `/comment`                | `validate_user()`                           | `POST /comments/create`             | `target_id: int`, `text: str`                      | Confirmation: “Comment submitted”          |
| `/comment_vote`           | `validate_user()`, `inline_vote_keyboard()` | `POST /comments/vote`               | `comment_id: int`, `vote: str (yes/no)`            | Confirmation: “Vote recorded”              |
| `/todo`                   | `validate_user()`                           | `GET /users/{user_id}/todo`         | `user_id: int`                                     | List of pending proposals/comments/reps    |
| `/status`                 | `validate_user()`                           | `GET /fractals/{fractal_id}/status` | `fractal_id: int`                                  | Summary of proposals/comments/votes        |

---

### **Service Account Adapter (Telethon) → Telegram Group Management**

| **Function**               | **Purpose**                   | **Inputs**                            | **Outputs**    |
| -------------------------- | ----------------------------- | ------------------------------------- | -------------- |
| `start_client()`           | Connects service account      | None                                  | Client ready   |
| `create_group()`           | Create private Telegram group | `title: str`, `user_ids: List[int]`   | `chat_id: int` |
| `generate_invite_link()`   | Make invite link              | `chat_id: int`                        | `link: str`    |
| `dm_invite_link()`         | DM users invite               | `user_id: int`, `link: str`           | None           |
| `add_bot_to_group()`       | Add bot to group              | `bot_id: int`, `chat_id: int`         | None           |
| `add_users_to_group()`     | Add users post-creation       | `chat_id: int`, `user_ids: List[int]` | None           |
| `remove_user_from_group()` | Remove user                   | `chat_id: int`, `user_id: int`        | None           |
| `fetch_group_members()`    | Get current members           | `chat_id: int`                        | `List[int]`    |

---

### **Flow Example: Creating a Fractal & Initial Group**

1. **User**: `/start_fractal MyFractal "Description" 2025-12-01`
2. **Bot**:

   * Calls `validate_user()`
   * Sends `POST /fractals/create` → backend stores fractal
3. **Service Account**:

   * `create_group(title="MyFractal", user_ids=[user1, user2, ...])`
   * `generate_invite_link(chat_id)` for each user
   * `dm_invite_link(user_id, link)` to all users
   * `add_bot_to_group(bot_id, chat_id)` ensures bot is in the group
4. **Backend**:

   * Stores user-fractal membership
   * Ready for proposals/comments/votes

---

### **Flow Example: Proposal & Voting**

1. **User**: `/proposal "New Rule" "Allow X"`
2. **Bot**:

   * Calls `validate_user()`
   * `POST /proposals/create`
3. **Backend**:

   * Creates proposal record
   * Returns confirmation
4. **User**: `/proposal_vote 5 8`
5. **Bot**:

   * Validates user
   * Sends `POST /proposals/vote`
   * Inline keyboard could show updated vote

---

### **Deliberation & Representative Flow**

* `Service Account` manages group structure for each round:

  * `partition_into_groups()` in domain layer
  * `create_group()` for each new group
  * Invite links sent via `dm_invite_link()`
  * Bot joins via `add_bot_to_group()`
* Votes and top proposals are aggregated from backend
* New higher-level groups are created recursively until top round

---

✅ **Benefits of this mapping:**

1. Clear separation of **Bot**, **Service**, and **Backend** responsibilities.
2. Bot handles **user interaction**, minimal logic.
3. Service account handles **group creation & Telegram automation**.
4. Backend handles **data, rules, votes, proposals**, and fractal logic.
5. Easy to maintain, test, and extend for future platforms.

---

If you want, I can also **draw a visual diagram (boxes & arrows)** showing **users → bot → backend → service account → Telegram groups** for a quick reference for your dev team.

Do you want me to make that visual diagram next?
